# 问题记录

-----
#### <font color=red>图片遮罩不全</font>

![屏幕快照 2019-03-13 下午12.03.49](https://ws4.sinaimg.cn/large/006tKfTcly1g111bbg2v9j30ty0d814p.jpg "问题图片")

   1. **背景：**客户端上传图片，在plus上，上传记录蒙版展示不全，应该是位置问题

   2. **实现原理：**

      * 控件整个是个`collectionView`，`cell`里面有个`imageView`,蒙版采用`category`,封装为`UIImageView`的一个分类，提供一个`progerss`属性，加载图片时，加载进度传值给`progerss`，`progress`根据值大小控制蒙版进度和是否显示。

      * 设置`progress`的时候，蒙版大小采用`imageView`的`bounds`值，作为大小。

        ``` objective-c
        #import "UIImageView+Common.h"
        @implementation ImageLoadingView
        - (instancetype)initWithFrame:(CGRect)frame
        {
            self = [super initWithFrame:frame];
            if (self) {
                [self addSubview:self.opacityMask];
                [self.opacityMask addSubview:self.progressLabel];
                [self.opacityMask.layer insertSublayer:self.maskLayerUp atIndex:0];
            }
            return self;
        }
        - (UIView*)opacityMask
        {
            if (!_opacityMask) {
                _opacityMask = [[UIView alloc]initWithFrame:self.bounds];
                _opacityMask.backgroundColor = [kColorT_White colorWithAlphaComponent:.5];
            }
            return _opacityMask;
        }
        - (UILabel*)progressLabel
        {
            if (!_progressLabel) {
                _progressLabel = ({
                    UILabel *label = [[UILabel alloc]initWithFrame:self.bounds];
                    label.textAlignment = NSTextAlignmentCenter;
                    label.textColor = kColorR_111;
                    label.font = kFont7_10;
                    label.numberOfLines = 0;
                    label.text = @"图片上传中";
                    label;
                });
            }
            return _progressLabel;
        }
        - (CAShapeLayer*)maskLayerUp{
            if (!_maskLayerUp) {
                _maskLayerUp = [CAShapeLayer layer];
                _maskLayerUp.bounds = self.bounds;
                _maskLayerUp.fillColor = [kColorK_Pink colorWithAlphaComponent:.94].CGColor; // Any color but clear will be OK
                _maskLayerUp.path = [UIBezierPath bezierPathWithRect:CGRectMake(0, 0,  self.bounds.size.width, self.bounds.size.height)].CGPath;
                _maskLayerUp.opacity = 0.8f;
                _maskLayerUp.anchorPoint = CGPointMake(0, 0);
            }
            return _maskLayerUp;
        }
        - (void)setProgress:(float)progress{
            _progress = (1.0-progress);
             self.maskLayerUp.path = [UIBezierPath bezierPathWithRect:CGRectMake(0, self.opacityMask.frame.size.height*progress,  self.opacityMask.frame.size.width, self.opacityMask.frame.size.height*(1-progress))].CGPath;
            self.progressLabel.text = [NSString stringWithFormat:@"图片上传中%d%%",(int)((progress)*100)];
            
        }
        @end
        
        @implementation UIImageView (Common)
            - (void)setProgress:(NSNumber*)progress
        {
            objc_setAssociatedObject(self, @selector(progress), progress, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
            if (self.showProgress.boolValue) {
                self.loadingView.progress = self.progress.floatValue;
            }
        }
        - (void)setShowProgress:(NSNumber *)showProgress
        {
            objc_setAssociatedObject(self, @selector(showProgress), showProgress, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
            //判断是否展示进度条
            if (self.showProgress.boolValue) {
                if (self.image.progressStatus.integerValue!=2) {
                    if (!self.loadingView.superview) {
                        //X系列大小不准确？
        //                CGRect rect = CGRectMake(0, 0, (kScreen_Width-34)/5-6, (kScreen_Width-34)/5-6);
                        self.loadingView = [[ImageLoadingView alloc]initWithFrame:self.bounds];
                        [self addSubview:self.loadingView];
                    }
                    if (self.image.progressStatus.integerValue==3) {
                        self.loadingView.progressLabel.text = @"上传失败";
                    }
                }
            }else
            {
                if (self.loadingView&&self.loadingView.superview) {
                    [self.loadingView.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];
                    [self.loadingView removeFromSuperview];
                    self.loadingView = nil;
                }
            }
          
        }
        - (void)setUploadImage:(UIImage *)image WithProgressHandler:(void(^)(float percent))progress withSuccess:(void(^)(NSString *imagekey))successHander;
        {
            if (!image||!self.showProgress) {
                return;
            }
            //1.设置图片
            self.image = image;
            
            //2.获取token
            if (self.uploadToken) {
                //上传
                if (self.image.progressStatus.integerValue!=2) {
                   [self uploadImageWithProgressHandler:progress withSuccess:successHander];
                }else{
                    self.showProgress = @0;
                }
                
            }else
            {
                if (self.image.progressStatus.integerValue!=2) {
                    [self startUpLoadSuccess:^(NSString *token) {
                        self.uploadToken = token;
                        //上传
                        [self uploadImageWithProgressHandler:progress withSuccess:successHander];
                    } failed:^{
                        //获取token失败
                    }];
                }else
                {
                    self.showProgress = @0;
                }
            }
        }
        //category的其他功能，及添加属性的set get方法已省略
        ```

        

      * `collectionViewCell`大小是根据页面宽度计算的,不同屏幕宽度图片大小不同。

      * 图片加载时，plus宽度变大，而因为后面的cell是第一次加载，取到的bounds值不对（应该是70，显示64），所以显示出错。

   3. **产生原因：**

      1. <font color=red>修改bounds </font>  以为大小不对，是应为循环应用等原因，造成的大小未更新。通过打印数据得知，设置图片大小在`cell`的`layoutSubView`之前,所以不是大小的问题。
      2. <font color=blue>图片大小未更新</font>   `collectionViewCell`在设置图片的时候，还没有在页面上展示出来，所以大小不对。在复用的时候，大小就是对了的。

4. **解决办法：**

   ​	原来设置了 `setNeedsLayout` 在cell最后，但是没用。

   ​	在设置`cell` 的 `image`之前，先调用 `[cell layoutIfNeeded];`  [链接](https://segmentfault.com/q/1010000002732923?_ea=193700) 

   ​	测试了把 `setNeedsLayout` 移到前面 ，不能解决问题。有了`layoutIfNeeded` ， `setNeedsLayout` 有没有没什么影响

   ```objective-c
   -(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath
   {
    DisplayImageCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@"DisplayImageCell" forIndexPath:indexPath];
   //     [cell setNeedsLayout];
    [cell layoutIfNeeded];
    ...... 
        设置cell内容
    ······
    //[cell setNeedsLayout];
    return cell;  
   }
   ```


5. **相关内容：**

   ​	/来自苹果api的翻译/

   ​	`setNeedsLayout`:当需要调整视图子视图的布局时，在应用程序的主线程上调用此方法。此方法记录请求并立即返回。由于此方法**不强制立即更新**，而是**等待下一个更新周期**，因此可以在更新任何视图之前使用它来使多个视图的布局无效。此行为允许您将所有布局更新合并到一个更新周期，这通常对性能更好。

   ​	`layoutIfNeeded`  :使用此方法**强制视图立即更新其布局**。使用自动布局时，布局引擎会根据需要更新视图的位置，以满足约束的更改。使用接收消息的视图作为根视图，此方法从根开始布局视图子树。如果没有挂起的布局更新，则此方法在不修改布局或调用任何与布局相关的回调的情况下退出。

   ​	`layoutSubviews`：默认实现了使用您设置的任何约束来确定任何子视图的大小和位置。如果要强制布局更新，请在**下次图形更新之前调用`setNeedsLayout（）`方法**。如果要**立即更新视图的布局，请调用`layoutIfneeded（）`方法**。

-----

#### 页面滑动返回显示

1. **背景：** 工程师端，发送需求消息，点击发送消息跳转到聊天页面，在聊天页滑动返回时，滑到一半放手了，即没有返回页面。但是会出来一个加载框hub。
2. **产生原因：**  为了更新订单状态，在`viewWillAppear` 时，重新请求了数据。加载框就是请求数据的时候显示的。在滑动返回的时候，会触发本页面的 `viewWillDisappear` 和下个页面的 `viewWillAppear`。而返回事件如果放在`viewDidLoad`里面，则不能及时刷新数据。
3. **解决办法：** 需求时，状态基本不会变，只有一个报名，不报名，所以可以改为只加载一次，但订单包括刷新状态，滑动事件，建议保留。



侧滑返回时代吗调用

```objective-c
/*
 1.第一次push进来的时候两个方法都会调用，parent的值不为空。
 2.当开始使用系统侧滑的时候，会先调用willMove，而parent的值为空；
 3.当滑动结束后返回了上个页面，则会调用didMove，parent的值也为空，如果滑动结束没有返回上个页面，也就是轻轻划了一下还在当前页面，那么则不会调用didMove方法。
 */
- (void)willMoveToParentViewController:(UIViewController*)parent {
    [super willMoveToParentViewController:parent];
    NSLog(@"%s,%@",__FUNCTION__,parent);
    //第一次进入页面会调用，parent不为空，侧滑返回的时候，会调用，parent为空。因此根据parent字段判断是不是侧滑返回。侧滑返回添加标记
    if (!parent) {
        self.isSlidePoping = YES;//isSlidePoping;//判断是不是正在侧滑返回
    }
    
}

- (void)didMoveToParentViewController:(UIViewController*)parent {
    [super didMoveToParentViewController:parent];
    NSLog(@"%s,%@",__FUNCTION__,parent);
    if(!parent){
        NSLog(@"离开页面");
        
    }
    //退出页面的时候修改侧滑标记
    self.isSlidePoping = NO;
}

```

-----

- ##### 相关问题链接

  1. ###### 问题1  聊天侧滑返回，发送订单消息消失时间

     1. **背景：** 发送订单消息，在订单页面点击联系对方，跳到聊天页面，出现发送消息，点击发送，则发送订单，没点，点返回，则返回页面，发送订单消息不保留。

     2. **实现原理：** 发送订单进入聊天时，传来订单`model`，在页面出现的时候`insertMessage`添加本地消息，但不发送给对方。在页面消失时，或页面被杀死的时候，从数据源倒数，移除发送订单消息。采用 `insertMessage`，会保存在本地数据库，但是在为了防止在刷新数据的时候重新读取数据源，把数据移除掉。在页面消失的时候，判断数据源，用删除消息的方式移除数据。

        ​	在添加和移除消息的时间，采用了`viewWillAppear`和 `viewDidDispear`。
        ​	选择过程：开始选择`viewWillAppear` `viewWillDisappear`,是一对数据，不会错误。但页面返回的时候就会在侧滑开始时就移除了消息，会显示闪一下。而且页面还没有返回，发送订单消息不应该被移除。于是就把移除消息放在了`viewDidDispear`，但这样如果页面侧滑返回后松开手指，还会调用viewWillAppear,造成消息重复。同时也会调用聊天页面的viewDidAppear,所以并不能移动到viewDidAppear来解决。而移动到viewDidAppear的话也会在页面出现一会之后才显示消息，感觉不合理。所以要判断侧滑返回事件。

     3. **解决办法：**

        页面出现，消失之前会调用`- (void)willMoveToParentViewController:(UIViewController *)parent` 和 `- (void)didMoveToParentViewController:(UIViewController *)parent`。查到的解释如下。

        ```objective-c
         /*
        1.第一次push进来的时候两个方法都会调用，parent的值不为空。
        2.当开始使用系统侧滑的时候，会先调用willMove，而parent的值为空；
        3.当滑动结束后返回了上个页面，则会调用didMove，parent的值也为空，如果滑动结束没有返回上个页面，也就是轻轻划了一下还在当前页面，那么则不会调用didMove方法。
        */
        ```

        官方文档解释

        ```objective-c
        //在视图控制器添加或从容器视图控制器中删除之前调用。
        - (void)willMoveToParentViewController:(UIViewController*)parent;
        当视图控制器需要知道它已添加到容器时，它可以覆盖此方法。
        如果要实现自己的容器视图控制器，则必须在调用removeFromParentViewController方法之前调用子视图控制器的willMoveToParentViewController：方法，并传入父值nil。
        当您的自定义容器调用addChildViewController：方法时，它会自动调用视图控制器的willMoveToParentViewController：方法作为子项添加，然后再添加它。
        参数  parent  父视图控制器，如果没有父视图，则为nil。
        ```

        ```objective-c
        //在容器视图控制器中添加或删除视图控制器后调用。
        - (void)didMoveToParentViewController:(UIViewController *)parent;
        Discussion
        当视图控制器想要对添加到容器做出反应时，它可以覆盖此方法。
        如果要实现自己的容器视图控制器，它必须在转换到新控制器完成后调用子视图控制器的didMoveToParentViewController：方法，或者如果没有转换，则在调用addChildViewController：方法之后立即调用。
        removeFromParentViewController方法在删除子视图后自动调用子视图控制器的didMoveToParentViewController：方法。
        参数  parent  父视图控制器，如果没有父视图，则为nil
        ```

        
-----

#### attributeString LineBreakMode 文字显示不全
1. **产生问题:**  用h5String 来显示alertView 这样就可以由后台控制提示框的显示了。但是今天遇到一个很奇怪的问题，在plus上，最后一行文字不显示。一直以为是alertView显示问题，分析了半天，发现还是普通label的问题。问题代码和效果如下：

   ![屏幕快照 2019-03-25 下午4.22.06](https://ws1.sinaimg.cn/large/006tKfTcly1g1f49eroy3j30kq0rkjvf.jpg)

 ```objective-c
     NSString *h5str = @"<font color='#111111'><strong><size value='14'>工程师个人:</size></strong><br/><size value='13'>①、实收金额=工单金额*(1-6%)-个人所得税<br/>②、平台按月合并缴税，工程师提现时平台会根据当月提现总金额计算个税。国家相关的税法规定，个人偶然所得</font><font color='#FF0000'><strong>超过800元</strong></font><font color='#111111'>需要交纳</font><font color='#FF0000'><strong>16%-25%</strong></font><font color='#111111'>的税</font></size><font color='#0076FF'><a href=\"/tax/taxIntroduce.html\"><strong><size value='13'>(查看</size><size value='10'>>></size><size value='13'>)</size></strong></a></font>，<size value='13'><font color='#111111'>同时强制要求平台代收代缴。个人偶然所得未超过800元，则无需纳税。<br/>③、平台仅收取6%的管理费，用于平台维护和升级，为您提供更好的服务。</font></size><br/><br/><strong><size value='14'><font color='#111111'>服务商 (企业):</font></size></strong><br/><size value='13'><font color='#111111'>①、服务商实收金额=工单金额*(1-6%)，其中6%为平台管理费。<br/>②、服务商(企业)无需缴纳个人所得税，但需要开具</font><font color='#FF0000'><strong>服务类增值税票</strong></font><font color='#111111'>给平台。</font></size>";
    
    
//    h5str = @"工程师个人:\n①、实收金额=工单金额*(1-6%)-个人所得税\n②、平台按月合并缴税，工程师提现时平台会根据当月提现总金额计算个税。国家相关的税法规定，个人偶然所得超过800元需要交纳16%-25%的税(查看>>)，同时强制要求平台代收代缴。个人偶然所得未超过800元，则无需纳税。\n③、平台仅收取6%的管理费，用于平台维护和升级，为您提供更好的服务。\n\n服务商 (企业):\n①、服务商实收金额=工单金额*(1-6%)，其中6%为平台管理费。\n②、服务商(企业)无需缴纳个人所得税，但需要开具服务类增值税票给平台。";
    
    if ([h5str containsString:@"<size"]) {
        h5str = [h5str stringByReplacingOccurrencesOfString:@"<size value='" withString:@"<span style='font-size:"];
        h5str = [h5str stringByReplacingOccurrencesOfString:@"</size>" withString:@"</span>"];
    }

    NSMutableArray *linkArrr = [[NSMutableArray alloc] init];
    if ([h5str containsString:@"<a"]) {
        h5str = [h5str stringByReplacingOccurrencesOfString:@"<a" withString:@"<link"];
        h5str = [h5str stringByReplacingOccurrencesOfString:@"</a>" withString:@"</link>"];

        NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"<link .*>*</link>" options:0 error:nil];
        NSArray *matches = [regex matchesInString:h5str options:0 range:NSMakeRange(0,h5str.length)];
        for(NSTextCheckingResult *result in [matches objectEnumerator]) {
            NSRange range = [result range];
            NSString *linkString = [h5str substringWithRange:range]; //取到的链接string-包括标签的

            //链接string去掉标签
            NSRegularExpression *regularExpretion=[NSRegularExpression regularExpressionWithPattern:@"<[^>]*>|\n" options:0 error:nil];
            NSString *stringLink=[regularExpretion stringByReplacingMatchesInString:linkString options:NSMatchingReportProgress range:NSMakeRange(0, linkString.length) withTemplate:@""];

            [linkArrr addObject:stringLink];
        }
    }
    
    NSAttributedString * attrStr = [[NSAttributedString alloc] initWithData:[h5str dataUsingEncoding:NSUnicodeStringEncoding] options:@{ NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType } documentAttributes:nil error:nil];
    
    
    UIView *customView = [[UIView alloc] init];
    customView.backgroundColor = [UIColor grayColor];
    
    UILabel *textLabel = [[UILabel alloc] init];
    textLabel.font = [UIFont systemFontOfSize:13];
    textLabel.numberOfLines = 0;
    textLabel.backgroundColor = [UIColor grayColor];
    textLabel.attributedText = attrStr;
//    textLabel.lineBreakMode = NSLineBreakByTruncatingTail;// NSLineBreakByWordWrapping 
    
    CGFloat panding = 53 + 16;
    textLabel.frame = CGRectMake(panding, panding, self.view.frame.size.width - panding - panding, 400);
    
    [self.view addSubview:textLabel];
 ```



需要后面的一行字没有显示，但label还有很多地方。

之后是看到一个文章，说`attributedTex`t不显示后面的… [链接](https://blog.csdn.net/wsh7365062/article/details/52237703) 然后就试了一下添加……然后就可以了……（就是注掉的那一行）

想知道为什么设置分行方式是`NSLineBreakByWordWrapping` 就不行。



#### 已经发布的程序，fir和蒲公英上的突然都不能安装了


今天下午，先是娟娟说点击提现报错崩溃，之后点不开，就打开就崩溃。以为是保存什么东西字段有问题，就连机测试，找到提现崩溃的原因（attributeString 先判断了contingString,后判断iskindOfClass:,contingString报错，应该反过来）。但没发现不能打开的问题。之后为了省事就直接连线安装了

然后是小科科说应用打不开，跟娟娟的问题一样，都是工程师端，连线解决，未查找原因。
之后客户端也是打不开。开始检查。因为是以前的版本，只能是证书问题，或者fir问题？😢；
试了蒲公英，fir,都是能下载，但是下载后变灰，不会变回来。预测是证书问题。
打开devicec查看log， 看到报错

```
[com.shenzhou.kehuduan] Bootstrap failed with error: <NSError: 0x281be17a0; domain: BKSProcessErrorDomain; code: 1 (bootstrap-failed); reason: "Failed to start job">

[com.shenzhou.kehuduan] Bootstrap failed with error: <NSError: 0x281bd0690; domain: BKSProcessErrorDomain; code: 1 (bootstrap-failed); reason: "Failed to start job">

Bootstrapping failed for <FBApplicationProcess: 0x10eb581e0; com.shenzhou.kehuduan; pid: -1> with error: Error Domain=BKSProcessErrorDomain Code=1 "Unable to bootstrap process with bundleID com.shenzhou.kehuduan" UserInfo={NSLocalizedDescription=Unable to bootstrap process with bundleID com.shenzhou.kehuduan, BKSProcessExitReason=0, NSLocalizedFailureReason=Failed to start job, NSUnderlyingError=0x281be1530 {Error Domain=NSPOSIXErrorDomain Code=3 "No such process" UserInfo={NSLocalizedFailureReason=The process failed to exec, NSLocalizedRecoverySuggestion=Consult /var/log/com.apple.xpc.launchd/launchd.log for more information, NSLocalizedDescription=Unable to get valid task name port right for pid 1133}}, BSErrorCodeDescription=bootstrap-failed}
```
看到一篇文章说查看device。登录appledevelepe, device已经注册了。之后看蒲公英的错误原因文档，用工具查看log，看到报错

```
<Notice>: -[IXSCoordinatedAppInstall _onQueue_acquireAssertionAndDoInstall]_block_invoke: Installation for <IXSCoordinatedAppInstall<0x14b200000> identifier:com.shenzhou.gongchengshi uuid:539C649A-1449-4E77-98DB-D897582109A8 intent:IXCoordinatorIntentInitiating creator/appDRI:App Store importance:UserWaiting state:IXAppCoordinationStateWaitingForInstall> failed: Error Domain=MIInstallerErrorDomain Code=13 "Failed to verify code signature of /private/var/installd/Library/Caches/com.apple.mobile.installd.staging/temp.JE9al0/extracted/Payload/Engineer.app : 0xe8008015 (A valid provisioning profile for this executable was not found.)" UserInfo={LibMISErrorNumber=-402620395, LegacyErrorString=ApplicationVerificationFailed, SourceFileLine=199, FunctionName=+[MICodeSigningVerifier 
```

查 `Failed to verify code signature of` 看到一篇文章说的

```
程序发布后，发现一个bug,需要在自己手机调试时，出现：a valid provisioning profile for this executable was not found错误.

原来是因为发布的时候把schema里的"Build Configuration"改成了release。而release对应的provision是用发布证书的。把"Build Configuration"改成了debug就好了。

because the App Transport Security policy requires the use of a secure connection
```

按照修改，然后打包，但是跟平常打包不一样，提示了这个

![屏幕快照 2019-04-09 下午5.06.55](https://tva1.sinaimg.cn/large/006tNbRwly1g9zrp8sod1j31h90u00xr.jpg)

感觉不对，让我重新创建证书，

然后就在开发者网站证书部分download了证书

![image-20190409175711423](https://ws1.sinaimg.cn/large/006tNc79ly1g1wj962os1j30ey09igog.jpg)

重新安装证书，然后在钥匙串中看到了 过期时间：今天下午……

原因：证书过期---更新证书 然后安装

![图片](https://tva1.sinaimg.cn/large/006tNbRwly1g9zrob667qj31j50u0n6o.jpg)



然后还是同一个包，在打包，就可以了。说明的确是我本地证书的问题。重新打包了所有应用，通知更新。



注：之前觉得自动管理证书就可以了，看起来不是。在打包的时候会验证本地的证书，如果时间到了就不能安装了。



注2.[证书签名原理](https://www.jianshu.com/p/fc56a70ee4fb)
使用RSA,非对称签名机制，两份密钥，公钥私钥。

从AppStore安装，苹果官方声称一对公钥私钥，手机内置一个公钥，私钥由苹果后台保存，上传app时，苹果后台用私钥对app数据进行md5值签名，下载后，由公钥验证签名。以此保证app是由苹果认证的。

其他安装方式：企业开发这账号In-House.企业分配限制（限制id）AD-Hoc.

验证： 

1. mac电脑（钥匙串）生成公钥M,私钥M.

2. mac把公钥M通过CSR文件申请证书，苹果服务器生成证书传给mac，证书包括公钥M,和HASH.

3. 开发是，编译完成后，用本地的私钥M对app 进行签名。并打包 包含公钥M,和HASH的证书，安装到手机

4. 验证手机的时候，手机中有公钥A, iOS系统获得证书，通过系统内的公钥A去验证数字签名是不是对的。



而在避免被滥用上，苹果添加了描述文件Provision profile.在生成证书时，添加描述文件，里面包含设备ids,AppId,Entitlements

```
在 Mac 上生成一对公私钥，这里称为公钥M，私钥M。
苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个iOS设备上。这里称为公钥A，私钥A。A:Apple
把公钥M传到苹果后台，用苹果后台里的私钥A去签名公钥M。得到一份数据包含了公钥M以及其签名，把这份数据称为证书。
在苹果后台申请AppID，配置好设备ID列表和APP可使用的权限，再加上第3步的证书，组成的数据用私钥A签名，把数据和签名一起组成一个Provisioning Profile文件，下载到本地Mac开发机。
在开发时，编译完一个APP后，用本地的私钥M对这个APP进行签名，同时把第4步得到的Provisioning Profile文件打包进APP里，文件名为 embedded.mobileprovision，把APP安装到手机上。
在安装时，iOS系统取得证书，通过系统内置的公钥A，去验证 embedded.mobileprovision的数字签名是否正确，里面的证书签名也会再验一遍。
确保了embedded.mobileprovision里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥M验证APP签名，验证设备ID是否在ID列表上，AppID是否对应得上，权限开关是否跟APP里的Entitlements对应等。
开发者证书从签名到认证最终苹果采用的流程大致是这样，还有一些细节像证书有效期/证书类型等就不细说了。

上面的步骤对应到我们平常具体的操作和概念是这样的：
第1步对应的是keychain里的“从证书颁发机构请求证书”，这里就本地生成了一对公私钥，保存的CertificateSigningRequest就是公钥，私钥保存在本地电脑里。
第2步苹果自己处理，我们不用管。
第3步对应把CertificateSigningRequest传到苹果后台生成证书，并下载到本地。这时本地有两个证书，一个是第1步生成的，一个是这里下载回来的，keychain会把这两个证书关联起来，因为它们的公私钥是对应的，在Xcode选择下载回来的证书的时，实际上会找到keychain里面对应的私钥去签名。这里私钥只有生成它的这台Mac才有，如果别的Mac也要编译签名这个App，把私钥导出给其他Mac使用，在keychain里面导出私钥，就会存成.p12文件，其他Mac打开后就导入私钥。
第4步都是在苹果网站上操作，配置AppID、权限、设备等，最后下载 Provisioning Profile文件。
第5步Xcode会通过第3步下载回来的证书(存着本地公钥)，在本地找到对应的私钥(第1步生成的)，用本地私钥去签名App，并把Provisioning Profile文件命名为embedded.mobileprovision一起打包进去。这里对App的签名数据保存分为两部分，Mach-O可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在_CodeSignature目录下。
第6、7步的打包和验证都是 Xcode 和 iOS 系统自动做的事。

证书：内容是公钥或私钥，由其他机构对其签名组成的数据包。
Entitlements：包含了App权限开关列表。
CertificateSigningRequest：本地公钥。
.p12：本地私钥，可以导入到其他电脑。
Provisioning Profile：包含了 证书/Entitlements 等数据，并由苹果后台私钥签名的数据包。


```

-----
#### JS交互
WKWebView  默认不会打开链接  需要实现方法
```
-(void)webView:(WKWebView*)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {
NSURL *URL = navigationAction.request.URL;
NSString *scheme = [URL scheme];
UIApplication *app = [UIApplication sharedApplication];
// 打电话
if ([scheme isEqualToString:@"tel"]) {
if ([app canOpenURL:URL]) {
[app openURL:URL];
// 一定要加上这句,否则会打开新页面
decisionHandler(WKNavigationActionPolicyCancel);
return;
}
}
// 打开appstore
if ([URL.absoluteString containsString:@"ituns.apple.com"]) {
if ([app canOpenURL:URL]) {
[app openURL:URL];
decisionHandler(WKNavigationActionPolicyCancel);
return;
}
}
decisionHandler(WKNavigationActionPolicyAllow);
}

```

注意最后的`decisionHandler(WKNavigationActionPolicyAllow); ` ，之前因为括号放错了，等于最后有情况没实现这个handle方法，崩溃，且木有信息……

js默认alert不弹出 需要实现
```
- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler {

UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"提醒" message:message preferredStyle:UIAlertControllerStyleAlert];
[alert addAction:[UIAlertAction actionWithTitle:@"知道了" style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) {
completionHandler();
}]];

[self presentViewController:alert animated:YES completion:nil];
}
```

js交互事件
1. 添加监听
``` 
viewWillAppear
[self.webView.configuration.userContentController addScriptMessageHandler:self name:@"gotoTel"];
```
2. 监听方法
```
- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {

//    message.boby就是JS里传过来的参数
NSLog(@"body:%@",message.body);
if ([message.name isEqual:@"gotoTel"]) {
if (self.repairPhoneData) {
self.repairPhoneData(message.body?((NSDictionary*)message.body):[NSDictionary dictionary]);
}

}
}
```

3. 移除监听
```
- (void)dealloc {
[_webView.configuration.userContentController removeScriptMessageHandlerForName:@"gotoTel"];
}
```

获取标题
1. 添加kvo
```
[self.webView addObserver:self forKeyPath:@"title" options:NSKeyValueObservingOptionNew context:NULL];
```
2. 代理事件
```
#pragma mark KVO的监听代理
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {

//网页title
if ([keyPath isEqualToString:@"title"]) {
if (object == self.webView) {
self.title = self.webView.title;
} else {
[super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
}
} else {
[super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
}
}
```
3. 移除监听
```
[_webView removeObserver:self forKeyPath:@"title"];
```


UIWebView
js交互
```
- (void)webViewDidFinishLoad:(UIWebView *)webView {
//    [Hub hideHUDQuery];

JSContext *jsContext = [webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"];
jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) {
context.exception = exceptionValue;
NSLog(@"异常信息：%@", exceptionValue);
};
jsContext[@"gotoSafari"] = ^() {
NSArray *arguments = [JSContext currentArguments]; //获取从js中传入的参数；
//3.遍历
for (id arg in arguments) {
NSLog(@"%@", arg); //这是传入的参数
//此处执行OC代码
dispatch_async(dispatch_get_main_queue(), ^{
NSString *textURL = [NSString stringWithFormat:@"%@", arg];
NSURL *cleanURL = [NSURL URLWithString:textURL];
[[UIApplication sharedApplication] openURL:cleanURL];
});
}

};
}
```

获取标题
1. 添加监听
```
 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(webViewDidChange:) name:@"WebHistoryItemChangedNotification" object:nil];
```

2. 添加方法
```
- (void)webViewDidChange:(NSNotification *)notific {

NSString *htmlTitle = @"document.title";
NSString *titleHtmlInfo = [self.webView stringByEvaluatingJavaScriptFromString:htmlTitle];
if ([titleHtmlInfo stringByReplacingOccurrencesOfString:@" " withString:@""].length > 0) {
self.title = titleHtmlInfo;
}
}
```

3. 移除监听
```
- (void)dealloc {

//移除观察者 self
[[NSNotificationCenter defaultCenter] removeObserver:self];
}
```

⚠️ 在一个保单页面 出现了返回页面崩溃问题  
不提示崩溃问题，根据内容没搜到原因
```
2019-04-24 09:46:29.271626+0800 Engineer[858:13513] -[WebScriptObject _disconnectFrame]: unrecognized selector sent to instance 0x6000027b2c90
2019-04-24 09:46:29.278768+0800 Engineer[858:13513] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[WebScriptObject _disconnectFrame]: unrecognized selector sent to instance 0x6000027b2c90'
*** First throw call stack:
(
0   CoreFoundation                      0x000000010b1026fb __exceptionPreprocess + 331
1   libobjc.A.dylib                     0x0000000109861ac5 objc_exception_throw + 48
2   CoreFoundation                      0x000000010b120ab4 -[NSObject(NSObject) doesNotRecognizeSelector:] + 132
3   CoreFoundation                      0x000000010b107443 ___forwarding___ + 1443
4   CoreFoundation                      0x000000010b109238 _CF_forwarding_prep_0 + 120
5   WebCore                             0x0000000116dadad7 _ZN7WebCore16ScriptControllerD2Ev + 23
6   WebCore                             0x00000001174b05b6 _ZN7WebCore5FrameD2Ev + 790
7   WebCore                             0x00000001174b086e _ZN7WebCore5FrameD0Ev + 14
8   WebCore                             0x00000001174d6d0f _ZN7WebCore4PageD2Ev + 3391
9   WebKitLegacy                        0x0000000115da8886 _ZN6WebKit22DeferredPageDestructor14tryDestructionEv + 118
10  WebKitLegacy                        0x0000000115d941cf __29-[WebView(WebPrivate) _close]_block_invoke + 431
11  WebCore                             0x0000000117691e16 _ZL15HandleRunSourcePv + 790
12  CoreFoundation                      0x000000010b069be1 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17
13  CoreFoundation                      0x000000010b069524 __CFRunLoopDoSources0 + 436
14  CoreFoundation                      0x000000010b063b1f __CFRunLoopRun + 1231
15  CoreFoundation                      0x000000010b063302 CFRunLoopRunSpecific + 626
16  WebCore                             0x00000001166aff55 _ZL12RunWebThreadPv + 565
17  libsystem_pthread.dylib             0x000000010cd502eb _pthread_body + 126
18  libsystem_pthread.dylib             0x000000010cd53249 _pthread_start + 66
19  libsystem_pthread.dylib             0x000000010cd4f40d thread_start + 13
)
libc++abi.dylib: terminating with uncaught exception of type NSException
```

经测试，移除监听方法走了。在`webViewDidChange:`方法中，写了 `stringByReplacingOccurrencesOfString` 就会崩溃，不写就不会。但是断点走不到它。
查原因说因为`stringByReplacingOccurrencesOfString`方法只在主线程走，添加了dis回到主线程方法，无效。后尝试取消监听方法，用系统方法改变标题
```
-(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType {
NSString *htmlTitle = @"document.title";
NSString *titleHtmlInfo = [self.webView stringByEvaluatingJavaScriptFromString:htmlTitle];
return YES;
}
```
添加上这个方法程序就不崩溃了（原先有shouldStartLoadWithRequest方法，做的不同事件）。添加了这个方法，监听没有移除 但是也没有崩溃了。⚠️⚠️⚠️⚠️原因未知

-----

#### 页面background Fetch 造成的页面问题

应用会在后台被杀死后，再次打开，会有一堆提示超时。在程序切换时，屏幕快照显示提示出错。刚打开应用，显示接口超时。出现占位图。偶现。在应用在后台挂起到杀死，再次打开程序偶现。

分析原因，首先是要观察后台运行情况。于是仿照上传数据统计m，写了统计方法调用的，让他在连线测试是打印出来，默认的存储在本地，由此查看后台过程。

发现  在后台自己调用FinishLaunching 方法，由此走了首页的viewDidLoad 和 viewWillAppear ,而在这里面，基本上都有网络请求相关内容，所以会调用接口，但是之后就被关闭，造成接口调用未完成，在下次打开app时，造成超时。

原以为跟接口调用有关，后来发现是 fetch 问题。

    ```
    iOS 7 新增加的一个选项，用于即使在后台，也需要频繁更新数据的应用。例如一个 PM2.5 的应用，需要几个小时更新一次数据，那么可以开启此选项，设置一个时间间隔，从而让 iOS 在间隔时间内在后台启动该应用，执行指定数据的获取工作，而此过程最多只能执行 30 秒钟。
    
    应用程序可以从网络中有规律的下载新数据；
    
    注册方法为：在程序的Info.plist中，将UIBackgroundModes键值设置为fetch，然后在app delegate中，使用方法setMinimumBackgroundFetchInterval:来设置下载新数据操作之间的最小时间间隔。另外，必须在app delegate中实现application:performFetchWithCompletionHandler:方法以执行任意的下载。
    ```



    ```
    app没有运行(不在前台也不在后台)，被Fetch事件唤醒执行.这种情况的测试方法如下:
    
    Product->Scheme->Edit scheme 在Debug模式选中Options,点选Launch due to a background fetch event，运行即可。
    可以观察到当Fetch事件到来时，app先进入后台，再执行- (void)application:(UIApplication *)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler{}。
　　```


在xcode调试，发现启动fetch事件，跟打印事件一样。


    正常
    ☀️START
    2019-06-11 16:41:46,☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️FinishLaunching🧸🧸🧸
    
    2019-06-11 16:41:47,🖌🖌🖌🖌🖌🖌 Home_RootViewController - viewDidLoad
    2019-06-11 16:41:47,🖌🖌🖌🖌🖌🖌 Home_RootViewController - viewWillAppear
    2019-06-11 16:41:48,📒📒📒📒📒didRegisterForRemoteNotificationsWithDeviceToken
    2019-06-11 16:41:48,📒📒📒📒📒didRegisterForRemoteNotificationsWithDeviceToken
    2019-06-11 16:41:48,📒📒📒📒📒didRegisterForRemoteNotificationsWithDeviceToken
    2019-06-11 16:41:48,☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️BecomeActive🍭🍭🍭
    
    2019-06-11 16:41:50,☔️☔️☔️☔️☔️☔️☔️☔️☔️☔️☔️☔️☔️☔️☔️☔️☔️☔️☔️☔️☔️ResignActive🙊🙊🙊 
    2019-06-11 16:41:51,📒📒📒📒📒applicationDidEnterBackground
    模拟器走fetch
    ☀️START
    2019-06-11 16:58:13,☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️☀️FinishLaunching🧸🧸🧸
    
    2019-06-11 16:58:14,📒📒📒📒📒performFetchWithCompletionHandler
    
    2019-06-11 16:58:14,🖌🖌🖌🖌🖌🖌 Home_RootViewController - viewDidLoad
    2019-06-11 16:58:14,🖌🖌🖌🖌🖌🖌 Home_RootViewController - viewWillAppear

fetch最多调用30s 但我的 performFetchWithCompletionHandler 事件里面 直接写了 completionHandler 造成走了finishLaunching,但是事件被截断了，有请求也没有继续执行。所以造成再打开超时。

因此在 completionHandler 事件里面 添加了延迟20s调用，用做给接口的时间。完成。

[相关文章](https://www.jianshu.com/p/82f639012f3e)

经测试 直接调用也会给30s时间处理

```
#pragma mark 后台刷新数据界面回调
-(void)application:(UIApplication *)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler {

NSLog(@"🤚=============performFetchWithCompletionHandler回调");
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
[WebLoadRecod writefile:@"💙💙💙💙失败后的3s"];
});
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
[WebLoadRecod writefile:@"🧡🧡🧡🧡失败后的5s"];
});
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
[WebLoadRecod writefile:@"❣️❣️❣️❣️❣️失败后的10s"];
});
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(20 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
[WebLoadRecod writefile:@"💚💚💚💚失败后的20s"];
});
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(29 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
[WebLoadRecod writefile:@"💜💜💜💜失败后的29s"];
});
//Tell the system that you ar done.
completionHandler(UIBackgroundFetchResultFailed);
}

```

这个全部都会打印，而且也更新的ui。


根据单独调用background Fetch事件， 最后的completionHandler事件是结束事件。加延时的话，会走后面的“失败后的x秒”提示，走完之后就不会提示了。（给completionHandler延时21s,能打印到20s提示,但不会打印29s提示）

延时前
```
=============performFetchWithCompletionHandler回调
2019-06-13 15:25:30.938730+0800 Engineer[32963:228041] WARNING: URLSession (or NSURLConnection) is using SPDY protocol, which is deprecated and will be removed in a future release
2019-06-13 15:25:30.984128+0800 Engineer[32963:227971] [🔔函数名:-[DemandListViewController filterView]] [🌷行号:289]:
_filterView.shadowY == 191.000000
2019-06-13 15:25:31.083068+0800 Engineer[32963:227971] [🔔函数名:+[WebAPIClient getJSONWithUrl:parameters:success:fail:showHub:hubString:]_block_invoke_2] [🌷行号:90]:
🐸✅Request:Succcess, [GET]URL:http://10.60.1.222:8080/server/version/userVersionInfo, para:{

2019-06-13 15:25:31.112134+0800 Engineer[32963:227971] 🐦[XGDemo] Push Is ON
2019-06-13 15:25:31.120015+0800 Engineer[32963:227971] [🔔函数名:+[WebAPIClient getJSONWithUrl:parameters:success:fail:showHub:hubString:]_block_invoke_2] [🌷行号:90]:
🐸✅Request:Succcess, [GET]URL:http://10.60.1.222:8080/bannerController/v3/url, para:(null)

2019-06-13 15:25:31.129888+0800 Engineer[32963:227971] [🔔函数名:+[WebAPIClient getJSONWithUrl:parameters:success:fail:showHub:hubString:]_block_invoke_2] [🌷行号:90]:
🐸✅Request:Succcess, [GET]URL:http://10.60.1.222:8080/server/V3/extension/mainExtension, para:

```

延时后
```
🤚=============performFetchWithCompletionHandler回调
2019-06-13 15:26:49.207167+0800 Engineer[32996:229491] WARNING: URLSession (or NSURLConnection) is using SPDY protocol, which is deprecated and will be removed in a future release
2019-06-13 15:26:49.263650+0800 Engineer[32996:229382] [🔔函数名:-[DemandListViewController filterView]] [🌷行号:289]:
_filterView.shadowY == 191.000000
2019-06-13 15:26:49.354004+0800 Engineer[32996:229382] [🔔函数名:+[WebAPIClient getJSONWithUrl:parameters:success:fail:showHub:hubString:]_block_invoke_2] [🌷行号:90]:
🐸✅Request:Succcess, [GET]URL:http://10.60.1.222:8080/server/version/userVersionInfo, para:{
2019-06-13 15:26:49.359605+0800 Engineer[32996:229382] 🐦[XGDemo] Push Is ON
2019-06-13 15:26:49.375720+0800 Engineer[32996:229382] [🔔函数名:+[WebAPIClient getJSONWithUrl:parameters:success:fail:showHub:hubString:]_block_invoke_2] [🌷行号:90]:
🐸✅Request:Succcess, [GET]URL:http://10.60.1.222:8080/bannerController/v3/url, 
2019-06-13 15:26:49.439700+0800 Engineer[32996:229382] [🔔函数名:+[WebAPIClient getJSONWithUrl:parameters:success:fail:showHub:hubString:]_block_invoke_2] [🌷行号:90]:
🐸✅Request:Succcess, [GET]URL:http://10.60.1.222:8080/server/V3/extension/mainExtension, para:{

2019-06-13 15:26:49.609336+0800 Engineer[32996:229382] [🔔函数名:+[WebAPIClient postJSONWithUrl:parameters:success:fail:showHub:hubString:]_block_invoke] [🌷行号:195]:
🐸✅Request:Succcess, [POST]URL:http://10.60.1.222:8080/v3/SpinnerController/directionVo,para:(null)

2019-06-13 15:26:49.841544+0800 Engineer[32996:229382] [🔔函数名:-[DemandListViewController loadWebData]] [🌷行号:138]:
typeCode == (null)
2019-06-13 15:26:49.842019+0800 Engineer[32996:229382] [🔔函数名:-[DemandListViewController loadWebData]] [🌷行号:139]:
typeDirection == (null)
2019-06-13 15:26:49.842549+0800 Engineer[32996:229382] [🔔函数名:-[DemandListViewController loadWebData]] [🌷行号:140]:

2019-06-13 15:26:50.205034+0800 Engineer[32996:229382] [🔔函数名:-[AppDelegate changeTestIcon]_block_invoke_3] [🌷行号:661]:
失败
2019-06-13 15:26:50.342208+0800 Engineer[32996:229382] [🔔函数名:+[WebAPIClient postJSONWithUrl:parameters:success:fail:showHub:hubString:]_block_invoke] [🌷行号:195]:
🐸✅Request:Succcess, [POST]URL:http://10.60.1.222:8080/v3/ticket/all?pageIndex=0&pageSize=10,para:{

2019-06-13 15:26:52.175778+0800 Engineer[32996:229382] [🔔函数名:-[AppDelegate application:performFetchWithCompletionHandler:]_block_invoke] [🌷行号:264]:
💙💙💙💙失败后的3s
2019-06-13 15:26:54.638200+0800 Engineer[32996:229382] [🔔函数名:-[AppDelegate application:performFetchWithCompletionHandler:]_block_invoke_2] [🌷行号:268]:
🧡🧡🧡🧡失败后的5s
2019-06-13 15:26:59.152615+0800 Engineer[32996:229382] [🔔函数名:-[AppDelegate application:performFetchWithCompletionHandler:]_block_invoke_3] [🌷行号:272]:
❣️❣️❣️❣️失败后的10s
2019-06-13 15:27:10.170018+0800 Engineer[32996:229382] [🔔函数名:-[AppDelegate application:performFetchWithCompletionHandler:]_block_invoke_4] [🌷行号:276]:
💚💚💚💚失败后的20s
```

-----

#### 首次点击聊天页面缓慢

之前有个需求，把聊天独立出来，由子类实现方法重写来独立父类，使包可以替换。

子类继承不是很好的解藕方法，因为父类方法名变了，会造成子类也会变。但是针对聊天，暂时没有更好的办法。可以自己修改定制一套自己的ui，就不动了，但是怕他们的方法增加，因此暂时不考虑。

子类重写父类的方法，采用尽量super，因为一直父类方法名称及实现，所以用  extention 来实现公开父类方法。（注：此方法在已知父类方法名时用，要谨慎，如果.m里方法没实现，则会崩溃）

重写也造成一定的性能浪费：比如重写在原方法之后，会造成先初始化一遍之前的，在初始化之后的，其实没必要。



遇到的问题是，第一次点击到聊天详情页面时，加载缓慢。

用timer profile 查询问题



![time profile](http://ww3.sinaimg.cn/large/006tNc79ly1g3yi2qj0i8j311k0u0aho.jpg)



发现较多时uiimage的问题。加载图片耗时。

而这些图片，是原页面的图片，就是加载bundel内图片有问题。而bundel 是原来系统图片 现在也用不到了。都有自己的图片替换，所以解决办法是把图片移除（也减小包体积）。运行发现有一个图片数组，加载一组图片，会因插入nil崩溃，所以把那句注试掉，并写好更新备注。

-----

#### 统计代码行数

去空行
` find . -name "*.m" -or -name "*.h" -or -name "*.xib" -or -name "*.c" |xargs grep -v "^$"|wc -l `

查看文件个数
`ls -lR| grep "^-" | wc -l` 

-----

#### pod 创建Tests,UITests文件

需要在podFile里面循环创建
```
platform :ios, '8.0'
targetsArray = ['User', 'UserUITests', 'UserTests']
#target “User” do
targetsArray.each do |t|
    target t do
        pod someThing
        .....
        
    end
end

```



之后文件里会出现xcconfig文件

![1565006158101](http://ww2.sinaimg.cn/large/006tNc79ly1g5p1voba5fj30i80uoadf.jpg)



相应targets里面也会出现config.file

![1565006211057](http://ww4.sinaimg.cn/large/006tNc79ly1g5p1w7wm77j314m0u0ajj.jpg)



test里面  ` $(inherited)`  也会有内容啦 否则在test里面是空的

-----

#### tests 

```
“未能安装应用，因为它已损坏或缺少必要的资源。”  ==> 修改Targets-Tests-General-HostApplication
缺少文件 ，pods需要设置tests的target的内容，同上
```


```
tests-BuildPhases里面添加文件：可以选择文件-边栏TaegetMembership打勾添加，也可以在BuildPhases里点击add批量添加（快得多，但要注意tests里面要移除uitests.m文件）
```

```
“未能载入软件包“UserUITests”。 请尝试重新安装软件包。” ==>  还是文件的链接文件的问题、、
把BundleLoader改为跟Tests一样的@（Test_Host）
【但是测试里面有Test_Host属性，UITest没有，之前认为应添加Test_Host 就把它的内容的地址赋值过去了，现在感觉是因为这个地址所以bundle的包、frameWork的包的路径不对，所以能编译不能运行】。
修改了Test_Host后，运行开始报错，缺少alipay.frameworkt，添加后仍报错，缺少CMMotionManager in AlipaySDK，所以对照添加了所有的包，运行成功。【一把辛酸泪……搞不定了放一段也好……说不定啥时候就解决了……】
```



```
	运行工程师的unit Tests的时候，总会崩溃在地图开启的地方，报错 “Invalid parameter not satisfying: !stayUp || CLClientIsBackgroundable(internal->fClient)” 
	百度查到的是需要在info里面添加background运行的许可内容，但是测试没有这个。
	测试在info里面添加/删除 许可/提示等 都没有用
	到处搜不到…… 又停了好久…… 然后试了试……把app上的项目给删了…… 严格来说是吧EngineerUITests文件给删了…… 然后可以了运行成功了…… 【我也没法跟你解释  因为我是一只小白兔……】
```

-----


#### UITests相关问题啊

1. UITests 不能访问原有APP的任何变量,所以只能通过某个界面特有的元素`Element` 来进行判断。每次运行一个文件需要有 `setUp` 里面的` launch` 才能启动，可以设置通用变量（如登录账号等），但如果在`setUp`里面设置的话，虽然是全局的，但是一个文件里面的不同测试用例，都是从`setUp`里面取的初试值。前面的测试用例调用了`renewPhoneNumber`后重置了测手机号，到下一个测试用例还会去`setUp`里面的值，而不是刚才`renew`的。**等于重新开始的**。

2. 可以添加base文件啊，创建基于`XCTestCase`的`UITests` 文件，然后创建 `.h` 文件,把 `@interface` 拿过去，然后可以设置公用方法，例如字段判断，或者登录什么的，其他测试文件就能引用了。

3. 找不到元素 - “[Timestamped Event Matching Error: Failed to find matching element](https://stackoverflow.com/questions/36597862/xcode-timestamped-event-matching-error-failed-to-find-matching-element)” ，设置`isAccessibilityElement`, 添加相应的  `accessibilityIdentifier`. 这个属性是默认是`no`的，如果在xib里面，在侧边栏设置打勾和id。

    但是不是都加上都好，例如在`NSObject的分类`里面添加了set方法（是看`TTTAttributedLabel`这样写的，人家是设为no的）

   ```
   - (BOOL)isAccessibilityElement {
       return YES;//NO;
   }
   ```

   然后如果统一设置为`YES`, 则会点击啥都显示的点击`window`，其他元素就都记录不了了。根据这个才知道不能都设置。

   例如：客户端发单页面，点击一行弹出一个`view`(在`self.view`上)，然后view一半一个`tableView`,选择某项收回赋值。初始根据小秦写的，给`view`设置可辅助，设置一个`id`,然后再给`tableView`设置可辅助，设置一个`id`。然后获取页面元素，直接获取 `app.tableView`,只有一个，在 `app.otherElement`里面有`view`,能找到`view`的`id`,获取到这个元素之后，`view.tables/cells/otherElement`等都**没有值**,或者取cell的时候录屏有一个`n多层的otherElement  tap` ,直接运行肯定不对。找不到`tableView` 的内容。后来吧`view`的`id`和属性关闭，用`app.tables`可以找到内容了。所以**要适当，用到的设置**。

4. `tableView`的嵌套，会取到嵌套里面的`cell`。

   直接 `orderTable.cell` 会取到 原`orderTable的cell+实施里面嵌套的cell`。排序就是**原生+嵌套**，所以按顺序找`cell`判断的时候需要注意。

   嵌套的`cell`可以单独取到：

   ```objective-c
    XCUIElement *implementCell = [orderTableView.cells containingType:XCUIElementTypeStaticText identifier:@"实施进度"].element;//取实施cell
   XCUIElement *impleTable = implementCell.tables.firstMatch;//取嵌套进去的table
   impleTable.cells 嵌套的cell的集合。
   ```

5. 正则判断内容

   ```objective-c
    		NSString *format = [NSString stringWithFormat:@"label 1⃣️ contains '%@' 2⃣️", @"签到地址:"];//写正则format
       NSPredicate *preset = [NSPredicate predicateWithFormat:format /*3⃣️*/];//添加NSPredicate
       XCUIElement *element = [app.tables.staticTexts /*4⃣️*/ elementMatchingPredicate:preset];//取element
       
    		XCTAssert(element.exists5⃣️, @"签到地址显示");
   ```

   ⚠️   1⃣️2⃣️ `format`写法，文字的话是 `label  contains  '%@'` 注意 `label/引号` ,3⃣️正则的`forma`t后面是一个`string`, ` [NSPredicate predicateWithFormat:@"label contains '%@'", @"签到地址:"]` 这样写到`exist`运行报错。4⃣️ `matchin`前面是`.staticTexts`。5⃣️ `exists`判断存在

   

   相关的判断-i71摘录

   ```objective-c
   - (XCUIElement *)elementWith:(NSString *)text {
       return self.app.staticTexts[text];
   }
   
   - (XCUIElement *)elementWithPrefix:(NSString *)prefix {
       NSString *format = [NSString stringWithFormat:@"label beginswith '%@'", prefix];
       return [self staticTextElementWithPredicateFormat:format];
   }
   
   - (XCUIElement *)elementWithContains:(NSString *)content {
       NSString *format = [NSString stringWithFormat:@"label contains '%@'", content];
       return [self staticTextElementWithPredicateFormat:format];
   }
   
   - (XCUIElement *)staticTextElementWithPredicateFormat:(NSString *)format {
       NSPredicate *predicate = [NSPredicate predicateWithFormat:format];
       XCUIElement *element = [self.app.staticTexts elementMatchingPredicate:predicate];
       return element;
   }
   
   - (void)expectObjectExist:(nullable id)object description:(NSString *)desc timeout:(NSTimeInterval)seconds {
       [self expectationWithPredicate:@"exists == 1" evaluatedObject:object description:desc timeout:seconds];
       [self expectationWithPredicate:@"hittable == 1" evaluatedObject:object description:desc timeout:seconds];
   }
   
   - (void)expectObjectNotExist:(nullable id)object description:(NSString *)desc timeout:(NSTimeInterval)seconds {
       [self expectationWithPredicate:@"exists == 0" evaluatedObject:object description:desc timeout:seconds];
   }
   
   // desc不能为nil，否则会功能不正常，why？可以传空字符串
   - (void)expectationWithPredicate:(NSString *)predicateStr
                    evaluatedObject:(nullable id)object
                        description:(NSString *)desc
                            timeout:(NSTimeInterval)seconds {
       NSPredicate *predicate = [NSPredicate predicateWithFormat:predicateStr];
       XCTestExpectation *expectation = [self expectationForPredicate:predicate evaluatedWithObject:object handler:nil];
       expectation.expectationDescription = desc;
       [self waitForExpectations:@[expectation] timeout:seconds];
   }
   ```

6. 循环找cell -- 不是最优 待优化

   ```objective-c
   //首页滑动 
       XCUIElement *tableView = app.scrollViews.otherElements.tables[@"demandListTable"];
       
       //点击cell 	1⃣️
       XCUIElementQuery *qure = [tableView.cells containingType:XCUIElementTypeStaticText identifier:@"ticketType"];
       
       DebugLog(@"%lu",(unsigned long)qure.count);
       
       //如果没有循环滑动～有用～～～
       //逻辑--当不存在-滑动  当存在且没有两个字-结束
       XCUIElement *cell;
       while ( qure.count > 0) {
           [tableView swipeUp]; //2⃣️
           for (int i = 0; i < qure.count; i ++) {
               if (!([qure elementBoundByIndex:i].staticTexts[@"领主可见"].exists  || [qure elementBoundByIndex:i].staticTexts[@"合伙人可见"].exists) && [tableView.cells elementBoundByIndex:i].images[@"icon-order-apply"].exists) {
                   cell = [qure elementBoundByIndex:i];
                   break;//3⃣️
               }
           }
           if (cell) {
               break;//4⃣️
           }
       }
       [cell tap];
   ```

    ⚠️   1⃣️ 只有判断`containingType` 没有反选判断元素不存在……  2⃣️ 这样会先滑动，就算第一个就是也会滑动.... 3⃣️ 一个break只会出来一层循环，需要4⃣️再出来一次才能退出while

7. 循环等待下一步操作 -- 不是最优，等待优化

    ```objective-c
       while (1) {
              sleep(5);//5s刷新一次数据,等待用户选中
              [orderTableView swipeDown];
              if ([app.staticTexts[@"客户生成协议中"] waitForExistenceWithTimeout:3]) {
               break;
              }
          }
    ```

      ⚠️   这样会5s刷新一次数据，但是也会造成停顿比较久。

8. test方法可以循环调用，开头用if判断，就可以单独用或者整体调用，但是要注意有while的

      ```objective-c
        XCUIApplication *app = [[XCUIApplication alloc] init];
          XCUIElement *orderTableView = app.tables[@"zxOrderTable"];
          
          if (!orderTableView.exists) {
              if (!app.buttons[@"全部订单"].exists) {
                  [app.tabBars.buttons[@"我的工单"] tap];
              }
              
              XCUIElement *signTable = app.tables[@"BiddenTicketTable"];
              if (!signTable.exists) {
                  [[app.buttons[@"GradientItemActionViewBtn_中标订单"] firstMatch] tap];
              }
              
              
              XCUIElementQuery *qure = signTable.cells;
              
              //等待接口加载成功
              XCTAssert([[signTable.cells firstMatch] waitForExistenceWithTimeout:3],@"列表内容显示");
              
              XCUIElement *cell;
              while (qure.count > 0) {
                  for (int i = 0; i < qure.count; i ++) {
                      XCUIElement *subCell = [qure elementBoundByIndex:i];
                      if (subCell.staticTexts[@"被选中，等待协议"].exists ) {
                          cell = [qure elementBoundByIndex:i];
                          break;
                      }
                  }
                  if (cell) {
                      break;
                  }
              }
              [cell tap];
              XCTAssert([app.tables[@"zxOrderTable"] waitForExistenceWithTimeout:3],@"order内容显示");
              
              orderTableView = app.tables[@"zxOrderTable"];
              
          }
      ```

9. isAccessibilityElement   “一个布尔值，指示该项是否是辅助应用程序可以访问的辅助功能元素。此属性的默认值为false。 如果接收器是UIKit控件，则默认值为true。”  这个属性值不是设置越多越好，尤其是嵌套页面的地方。
        [返回YES，所有子视图的可访问性会被隐藏，不可访问；返回NO,则相反。](https://www.jianshu.com/p/b039b98ad353)
   
10. uitests真机报错，正常运行没有报错
```
   Undefined symbols for architecture arm64:
     "_ZIM_SaveImage", referenced from:
         ImgSave(tagIMG, char const*) in libbankcard.a(gjimage.o)
     "_ZIM_LoadImage", referenced from:
         ImgLoad(tagIMG&, char const*) in libbankcard.a(gjimage.o)
     "_ZIM_DoneImage", referenced from:
         ImgLoad(tagIMG&, char const*) in libbankcard.a(gjimage.o)
   ld: symbol(s) not found for architecture arm64
   clang: error: linker command failed with exit code 1 (use -v to see invocation)
```
修改： UITests的Target文件：
ENABLE_ON_DEMAND_RESOURCES = NO;
ENABLE_TESTABILITY = NO;
MACH_O_TYPE = mh_execute;
SKIP_INSTALL = NO;
STRIP_STYLE = all;
IPHONEOS_DEPLOYMENT_TARGET = 8.0;


安装成功 但是运行报错：
```
2019-10-09 13:59:28.979079+0800 EngineerUITests-Runner[4122:947621] Running tests...
2019-10-09 13:59:29.017788+0800 EngineerUITests-Runner[4122:947621] 未能载入软件包“EngineerUITests”，因为其可执行文件不可载入。 请尝试重新安装软件包。
```

修改
ENABLE_TESTABILITY = NO;
报错： _ZIM_SaveImage

修改
ENABLE_ON_DEMAND_RESOURCES = yes；
报错：On-Demand Resources is enabled (ENABLE_ON_DEMAND_RESOURCES = YES), but is not supported for ui testing bundle targets

修改
MACH_O_TYPE = bundle;
报错： _ZIM_SaveImage

MACH_O_TYPE:设置可执行文件编译类型，

```
附：bankCard添加
1.包  IDAndBankCard
https://github.com/mxl123/IDAndBankCard

2.修改配置  
enable  bitCode no
enable testability no

3.模拟器编译错误 
模拟器上编译报错，真机上正常
ld: warning: ignoring file /Users/wuliuyan/Desktop/神州邦邦-代码/gcs-ios/Engineer/Vendors/BankCardScan/bank_io/exbankcardcore/libbankcard.a, missing required architecture x86_64 in file /Users/wuliuyan/Desktop/神州邦邦-代码/gcs-ios/Engineer/Vendors/BankCardScan/bank_io/exbankcardcore/libbankcard.a (3 slices)
Undefined symbols for architecture x86_64:
  "_BankCardNV12", referenced from:
      -[XLScanManagerControl parseBankImageBuffer:] in XLScanManagerControl.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)


错误原因：_BankCardNV12 在模拟器上不能用
解决办法：在使用它的那一段加上
 \#if !TARGET_IPHONE_SIMULATOR
\#endif

[#if语句使用](https://www.cnblogs.com/Black-R/p/5596050.html)
```

。。。。
谁给我说要在测试文件的targets文件里面的compile Source 和 copy bundle resources 什么的里面添加和工程一样的文件的……
我把它都删了 只留 compile Source里面的uitests.m的文件  然后……可以运行的……并且成功测试了的……
妈耶 我在哪里听到的谣言……嘤嘤嘤


11. 按钮导航栏找不到按钮，尤其是先设置了   
`self.navigationItem.rightBarButtonItem = nil; ` 
网络请求完成之后再设置
` [self setRightBlackBarItemWithTitle:@"增加"]; ` 
就找不到按钮，修改-添加                 
`dispatch_async(dispatch_get_main_queue(), ^{});`
把设置放到主流程中。使用 ` #define dispatch_main_sync(block)` 不行



-----

#### iOS13 

夜间模式：
要适配的话在设置一个imageSet,设置define颜色修改时添加两种。 默认的白色会自己变，tabbar上会变成黑色的。statusbar也会自己变。
不适配的话  在 `info.plist` 里面添加  `User Interface Style = （string）Light`,单个页面设置可以添加  `self.overrideUserInterfaceStyle = UIUserInterfaceStyleLight;` 

弹出页面样式：
`presentViewController:animated:completion:`  推出页面，推出的页面  `modalPresentationStyle` 属性 之前默认值是 `UIModalPresentationFullScreen = 0`,iOS13内末日改为  `UIModalPresentationAutomatic API_AVAILABLE(ios(13.0)) = -2,`    页面显示为层叠的，页面消失时,前一个页面不走 `viewWillAppear`. 修改可以给页面设置 `self.modalPresentationStyle = UIModalPresentationFullScreen;`

高德地图需要更新，逆地址编码不走回掉
信鸽需要更新，xcode11打包的收不到推送
`- (void)tableView:(UITableView *)tableView willDisplayFooterView:(UIView *)view forSection:(NSInteger)section`里面不能取  `tableView:cellForRowAtIndexPath:` 了，说页面没有更新完的时候不能调用，在之前不会提示，取高度改为 `view` 的 `frame`，在这个方法里已经有 `frame`了.



----
#### storeBord
2020.4停止使用`LaungingImage`,所有的都需要`LaungingScreen.storeBord`.
用`LaungingScreen.xib`会遇到换不了图片的问题，`storeBord`好一点，但是还是会有问题。
用`storeBord`,需要在设置里面设置地址 `LaungingScreenFile` ，之后可以拼接图片。
如果需要更换图片，用原来的imageView会不显示，需要删了，重新添加。



#### iOS13的坑
textView 富文本  带图片 图片有点击事件  
而且只有 13.0  之后的就修复了  qswl
添加了这个方法
```

- (BOOL)textView:(UITextView *)textView shouldInteractWithTextAttachment:(NSTextAttachment *)textAttachment inRange:(NSRange)characterRange interaction:(UITextItemInteraction)interaction {
    if ([[UIDevice currentDevice].systemVersion isEqualToString: @"13.0"]  && self.couldEdit) {
        [textView becomeFirstResponder];
    }
    return NO;
}

```

#### xcode11 Main.storyBord
xcode11默认创建文件采用了Scenedelegate.h ，关于页面的相关内容在Scenedelegate.m里面设置
但是有时会推不出来windows，比如腾讯的人脸识别的
然后就要不用storyBord,但是跟之前一样直接删了，打开就黑屏
解决是  把appdelegate里面的 UISceneSession lifecycle 注释掉
全部的方法：1. 删  删除Scenedelegate，  删除 target里面的mainInterface ，删除Main.storyBord,删 info.plist 里面的Application Scene Manifest 里面的main   2. 改 注释掉appdelegate里面的 UISceneSession lifecycle 3.在appdelegate里面加上原来的设置mainwindow的方法
如果不删Scenedelegate  只是换mainView的话，都不删，在Scenedelegate里面设置windows的相关方法就行



#### xcode11.2  textView用xib创建的崩溃

XCode升级到11.2，发现原来用到XIB的子类代码界面会在IOS12机型闪退.

错误原因：

> Could not instantiate class named _UITextLayoutView because no class named _UITextLayoutView was found; the class needs to be defined in source code or linked in from a library (ensure the class is part of the correct target)

建议1是手写代码避坑；2是下载老版本的Xcode。

硬打补丁

```objective-c
.h
#import <Foundation/Foundation.h>
 
NS_ASSUME_NONNULL_BEGIN
 
@interface UITextViewWorkaround : NSObject
+ (void)executeWorkaround;
@end
 
NS_ASSUME_NONNULL_END
  
 .m
  #import "UITextViewWorkaround.h"
#import <objc/runtime.h>
 
@implementation UITextViewWorkaround
 
+ (void)executeWorkaround {
    if (@available(iOS 13.2, *)) {
 
    }
    else {
        const char *className = "_UITextLayoutView";
        Class cls = objc_getClass(className);
        if (cls == nil) {
            cls = objc_allocateClassPair([UIView class], className, 0);
            objc_registerClassPair(cls);
#if DEBUG
            printf("added %s dynamically\n", className);
#endif
        }
    }
}
 
@end

Appdelegate.m
  
........
 
#import "UITextViewWorkaround.h"
 
@implementation AppDelegate
 
 
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
 
......
 
//解决Xcode 不能读取textView xib 崩溃
    [UITextViewWorkaround executeWorkaround];
    return YES;
}
```

