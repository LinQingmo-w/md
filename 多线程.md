

## 四种多线程方法和比较

### 1. pthread ###

pthread（POSIX thread）表示跨平台的的线程接口，适用于Unix\Linux\Windows等系统，是跨平台和可移植的，使用的语言是C语言，线程的生命周期是由程序员管理的，适用难度很大，所以几乎是不用的。



### 2. NSThread ###

NSThread的使用更加面向对象，简单易用，可以直接操作线程对象，使用的语言是OC，但是线程的生命周期是由程序员自行管理的，所以偶尔会使用。



### 3. GCD ###

GCD（Grand Central Dispatch）是苹果公司为多核的并行运算提出的解决方案，会自动利用更多的CPU内核（比如双核、四核），是纯C语言的，提供了很多强大的函数，能够自动的管理线程的生命周期（创建线程、调度任务、销毁线程），在平时的工作中经常使用。

核心是将任务添加到队列中。

解决死锁的办法: 就是将主队列的代码放到子线程中，不让其阻碍主线程的执行，这样等主线程空闲下来的时候，就可以去执行主队列上面的代码。



### 4.  NSOperation ###

NSOperation是OC语言中基于GCD的面向对象的封装，使用起来比GCD更加简单（面向对象），提供了一些用GCD不好实现的功能（例如：添加依赖），能够自动的管理线程的生命周期，在平时的工作中经常使用。

**苹果推荐使用** 

NSOperation是一个抽象类，所以无法直接使用，因为它的方法只有声明没有实现。核心就是将操作添加到队列当中。
使用时其实我们是对NSOperation子类的使用

```objectivec
NSInvocationOperation;
NSBlockOperation;
// 自定义operation
NSOperation;
```

将操作添加到队列，默认是异步执行。

可设置最大并发数，可设置队列的暂停、继续和取消全部。



## 线程安全

可以使用互斥锁，@synchronized(锁对象) { // 需要锁定的代码 }

OC在定义属性时有nonatomic和atomic两种选择

`atomic`：原子属性，为setter方法加锁（默认就是atomic）。线程安全，需要消耗大量的资源【**atomic不是绝对的线程安全， atomic的本质是保证get set方法的线程安全，并不是保证修饰的对象的线程安全。**】

`nonatomic`：非原子属性，不会为setter方法加锁。非线程安全，适合内存小的移动设备

```objectivec
//atomic加锁原理
@property (assign, atomic) int age;
 
 - (void)setAge:(int)age
 { 
 
     @synchronized(self) { 
        _age = age;
     }
 }

```



```objectivec
@interface Item:NSObject
@property(atomic,strong)NSMutableArray *mut
@end

-(void)setMut:(NSMutableArray *)mut{
    @synchronized(self){
        self.mut = mut;
    }
}
-(NSMutableArray *)mut{
 @sychronized(self){
       return _mut;
       }
}
```

但是，使用[self.mut objectAtIndex:index]就不是线程安全的，需要用锁来保证线程安全性。



## 线程间通信


>1 .一个线程传递数据给另一个线程
2 .在一个线程中执行完特定任务后，转到另一个线程继续执行任务

方法：

```objective-c
1. `NSThread`可以先将自己的当前线程对象注册到某个全局的对象中去，这样相互之间就可以获取对方的线程对象，然后就可以使用下面的方法进行线程间的通信了，由于主线程比较特殊，所以框架直接提供了在主线程执行的方法

- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;

- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);

```



```objective-c
2. `GCD`一个线程传递数据给另一个线程，如：
       
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
    
{   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        
        NSLog(@"donwload---%@", [NSThread currentThread]);
        
        // 1.子线程下载图片
        NSURL *url = [NSURL URLWithString:@"http://d.jpg"];
        
        NSData *data = [NSData dataWithContentsOfURL:url];
        
        UIImage *image = [UIImage imageWithData:data];
        
        // 2.回到主线程设置图片
        dispatch_async(dispatch_get_main_queue(), ^{
            
            NSLog(@"setting---%@ %@", [NSThread currentThread], image);
            
            [self.button setImage:image forState:UIControlStateNormal];
        });
    });
}

```



## 多线程相关内容

任务：同步任务(sync)、异步任务(async)

队列：串形队列(serial)、并发队列(concurrent)



![image-20191217230059013](https://tva1.sinaimg.cn/large/006tNbRwly1ga046x4x37j314s0dcaco.jpg)

同步并发队列：还是串行执行任务

同步串形队列：串形执行任务

异步串行：开启一个新线程，串形

异步并发队列：开启新线程，

主队列异步：没有开启新线程，串形。

**死锁**

注意：syn + 主队列：死锁

![img](https://upload-images.jianshu.io/upload_images/2177502-63aa523d23134833.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

```objectivec

- (void)viewDidLoad {
    [super viewDidLoad];
    
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@"线程死锁");
    });
}
```

>也就是说后添加的同步任务5是在`viewDidLoad`任务2之后，只有等待任务2执行完之后才能执行任务5，这就是串行队列的特点。但是任务5是一个同步任务，必须等任务5执行完才能执行其它任务，因此造成互相等待的死锁。



作者：ChinaChong
链接：https://www.jianshu.com/p/8bb77afd14e1
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

串形队列中执行同步任务容易死锁

serialQueue.async {

​	2

​	serialQueue.sync{

​		3

​	}

​	4

}

> serialQueue ，先进的2，因为是同步线程，所以先走2.
>
> 2是异步执行的时候进3，等3完成才走4，4完成2的全部事件才完成
>
> 但是同步队列，前一个没完成，后面一个不能进行，而前一个又等着3完成才走4 。所以死锁

## A事件完成后再进行B事件，多线程怎么处理

1. 

同步并发队列：concurrentQueue.sync

同步串形队列: serialQueue.sync

异步串形队列：serialQueue.async



2. serialQueue:

	(1). 

serialQueue.sync{1}

serialQueue.sync{2}/serialQueue.async{2}



​	(2). 

serialQueue.sync{

​	1

​	serialQueue.async{2}

}



​	(3). 

concurrentQueue.sync{1}

concurrentQueue.sync{2}/async{2}



​	(4).

concurrentQueue.async{

​	1

​	concurrentQueue.sync{2}

}



3. 分组，

	dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);

	dispatch_group_t group = dispatch_group_create();

	dispatch_group_aysnc(group,queue ^{1});

	dispatch_group_notify(group,dispatch_ger_main_queue(),^{ 2 });

4. 栅栏，

	dispatch_async(queue,^{1});

	dispatch_barrier_aysnc(queue,^{ wait });

	dispatch_async(queue,^{2});

5. 信号量

	

## 多线程会遇到的问题

1. 竞态：同时读写
2. 优先级倒置：
3. 死锁：相互依赖



## dispatch

dispatch_queue_t  //队列

dispatch_async(queue,^{}); //异步,不等结果返回就走下一步

dispatch_sync(queue,^{}); //同步，等执行完才走下一步

dispatch_set_target_queue(queue1,queue2);//队列-指定 1 的属性 为 2（属性：优先级，并/串形）

dispatch_after(time,queue,^{});//延迟执行，注意是到时间放到队列里，不是立即执行，会有时间偏差

disspatch_group_t //分组，可得到分组结果，具体如上面

dispatch_barrier_async(queue,^{});//栅栏，等栅栏上面的异步都执行完了，再执行栅栏，再执行栅栏下面的。

dispatch_apply(count,queue,^(index){});//重复添加几个

dispatch_suspend(queue);//线程挂起，暂停

dispatch_resume(queue);//线程恢复，继续

dispatch_semaphore_t  semaphore;//信号量 变量 为0时等待，为1或大于1，则减1而不等待

dispatch_semaphore_wait(semaphore,time);//等待信号量触发，等待时常   为0时等待，为1或大于1，则减1而不等待 ，就是wait执行减1操作

dispatch_semaphore_signal(semaphore);//数值加1

static dispatch_once_t pred;

dispatch_once(&pred,^{});//单例

dispatch_io/dispatch_data;//分段处理io和数据。





## 多个网络请求先后依赖

1. 嵌套调用 -- 不好处理逻辑

2. 1.通过信号量来实现(信号量就三个函数dispatch_semaphore_create , dispatch_semaphore_wait , dispatch_semaphore_signal)

3. ```objective-c
	dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);
	    dispatch_queue_t quene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
	    
	    //任务1
	    dispatch_async(quene, ^{
	        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
	        for (int i = 0; i<10; i++)
	        {
	            NSLog(@"j的值是:%d",i);
	        }
	        dispatch_semaphore_signal(semaphore);
	    });
	    //任务2
	    dispatch_async(quene, ^{
	        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
	        for (int i = 0; i<20; i++)
	        {
	            NSLog(@"i的值是:%d",i);
	        }
	        dispatch_semaphore_signal(semaphore);
	    });
	```



3. (推荐)通过 NSOperationQueue 中的依赖关系来操作,NSOperation 是对GCD的封装实现的,所以其优点肯定是高于GCD的.代码如下. 

	NSOperationQueue * queueeTest = [[NSOperationQueue alloc]init];
	    

	```objective-c
	queueeTest.maxConcurrentOperationCount = 1;
	
	NSBlockOperation * optionA = [NSBlockOperation blockOperationWithBlock:^{
	    
	    for (int i = 0; i<10; i++)
	    {
	        NSLog(@"i的值是:%d",i);
	    }
	}];
	NSBlockOperation * optionB = [NSBlockOperation blockOperationWithBlock:^{
	    
	    for (int j = 0; j<20; j++)
	    {
	        NSLog(@"j的值是:%d",j);
	    }
	}];
	
	//A依赖于B
	[optionA  addDependency:optionB];
	
	[queueeTest addOperation:optionA];
	
	[queueeTest addOperation:optionB];
	```

