## 系统框架

47条

将一些勒代码封装为动态库，并在其中放入描述其接口的头文件，这样做出来的东西叫框架。



Foundation：基类。使用NS前缀，提供了基础核心功能。

CoreFoundation：无缝桥接，把C语言数据结构转换为Foundation中的OC对象，或反转换，

UI框架：UIKit,提供构建在F oundation

OC经常需要使用底层C语言级的API,ARC只负责OC对象，所以要注意内存管理问题。



iOS基于UNIX系统，iOS的系统架构分为四层，由上到下一次为：可触摸层（Cocoa Touch layer）、媒体

层（Media layer）、核心服务层（Core Services layer）、核心操作系统层

Foundation：为所有的应用程序提供基本系统服务

Core Data框架管着理应用程序数据模型

Core Graphics框架帮助你创建图形

Core Animation允许你创建高级的动画和虚拟效果

OpenGL ES 框架提供2D和3D绘图工具

UIKit

Core Graphics

## 系统架构/架构模式



架构：是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计

#### MVC-面向对象：

controller负责事件，model是数据，view负责页面显示。controller持有model、view，view事件通过delegate和DataSource传递给C。Model可以设置Notificication\kvo, view的action由C处理。view和model之间不应该有数据关系。

缺点：胖model,controller过载，过度格力vm,产生太多轻量级的model，较差的可测试性，业务逻辑与视图逻辑强耦合

#### MVVM-响应式编程:

controller & view 直接通过viewModel 读取数据然后展示在界面上，双向绑定（通过viewModel 绑定view 与 model）

ReactiveCocoa：RAC,响应式编程

 

#### MVP-面向接口：

将处理逻辑都放到presenter中，presenter持有V,M，





## 设计模式

前人总结的、面对开发中常见问题的解决方案。

程序开发的套路和模版。

### 原则

[链接](https://www.jianshu.com/p/e5c69c7b8c00)

- 单一职责原则
- 开闭原则
- 里氏替换原则
- 接口隔离原则
- 依赖倒置原则
- 迪米特法则
- 组合/聚合复用原则

### 分类

#### 创建型

[书]() + [资料1](https://www.jianshu.com/p/e5c69c7b8c00)

##### **单例模式**

​	保证对于一个特有的类，只有一个公共的实例存在，预览加载一起出现，需要时才会创建。

​	eg. `[NSUserDefaults standardUserDefaults]`、`[UIApplication sharedApplication]` 、 ` [UIScreen mainScreen]`



##### **抽象工厂模式**

​	提供一个接口，用于创建与某些对象相关或依赖于某些对象的类家族，而又不需要指定它们的具体类。通过这种模式可以去除客户代码和来自工厂的具体对象细节之间的耦合关系。

​	类簇是一种把一个公共的抽象超类下的一些私有的具体子类组合在一起的架构。抽象超类负责声明创建私有子类实例的方法，会根据被调用方法的不同分配恰当的具体子类，每个返回的对象都可能属于不同的私有子类。

​	Cocoa将类簇限制在数据存储可能因环境而变的对象生成上。Foundation框架为`NSString`、`NSData`、`NSDictionary`、`NSSet`、和`NSArray`对象定义了类簇。公共超类包括上述的不可变类和与其相互补充的可变类`NSMutableString`、`NSMutableData`、`NSMutableDictionary`、`NSMutableSet`、和`NSMutableArray`。



##### **建造者模式**

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

- 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。
- 当构造过程必须允许被构造的对象有不同的表示时。

##### **工厂方法模式**

​	定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。

- 当一个类不知道它所必须创建的对象的类的时候。
- 当一个类希望由它的子类来指定它所创建的对象的时候。
- 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。



##### **原型模式** 

​	用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

​	原型模式是非常简单的一种设计模式, 在多数情况下可被理解为一种深复制的行为。在Objective-C中使用原型模式, 首先要遵循NSCoping协议(OC中一些内置类遵循该协议, 例如NSArray, NSMutableArray等)。



#### 结构型

#####  **MVC**

​	常用架构模式主要目的是将不同的代码归并为不同的模块，做到低耦合、代码分配合理、易于扩展维护。

##### **装饰模式**

​	在不修改原代码的基础上进行扩展。与继承最大的区别是：继承时，子类可以修改父类的方法，装饰模式不希望如此。

##### **适配器模式**

​	将一个类的接口转换为另一个类的接口，使原本互不兼容的类可以通过接口一起工作。

##### **外观模式**

​	用一个公共接口来连接多个类或其他数据类型。公共接口让多个类之间保持独立，解偶性良好。使用接口时，外部无需理解其背后的逻辑（透明），接口背后的逻辑修改了也不影响接口的使用。

##### **桥接模式**

​	将抽象部分与它的实现部分分离，使它们都可以独立地变化。

##### **组合模式** 

​	这种模式将互相关联的对象合成为树结构，以表现部分-全部的层次结构。它使客户代码可以统一地处理单独的对象和多个对象的合成结果。

​	合成对象是模型-视图-控制器聚集模式的一部分。



##### **享元模式** 

运用共享技术有效地支持大量细粒度的对象。

**适用性**

- 一个应用程序使用了大量的对象。
- 完全由于使用大量的对象，造成很大的存储开销。
- 对象的大多数状态都可变为外部状态。
- 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。
- 应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。

##### **代理模式** 

为其他对象提供一种代理以控制对这个对象的访问。

这种模式为某些对象定义接口，使其充当其它对象的代理或占位对象，目的是进行访问控制。这种模式可以用于为一个可能是远程的、创建起来开销很大的、或者需要保证安全的对象创建代表对象，并在代表对象中为其提供访问控制的场合。它在结构上和装饰模式类似，但服务于不同的目的；装饰对象的目的是为另一个对象添加行为，而代理对象则是进行访问控制。iOS中大量的使用了代理模式，UITableView，UIScrollView，AppDelegate等。

图中涉及的角色如下所示：

- 协议：定义代理和委托的共同接口（方法）
- 委托：根据指定的协议，委托代理去完成实现指定接口（方法）
- 代理：根据指定的协议，实现委托需要实现的接口（方法）



#### 行为型

用于描述对类或对象怎样交互和怎样分配职责。

##### **观察者模式**

​	定义对象之间的一种一对多的依赖关系，一个对象发生状态改变时，其相关以来的对象会得到通知并自动更新。

​	eg. `NotificationCenter`,`KVO`,`RAC(ReactiveCocoa)`

##### **备忘录模式**

​	在不破坏封装性的前提下，捕获一个对象的内部状态，并将该对象之外保存这个状态，这样以后就可以将该对象会发哦到保存之前的状态。

##### **职责链模式** 

​	使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

##### **命令模式** 

​	将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。请求对象将一或多个动作绑定在特定的接收者上。命令模式将发出请求的对象和接收及执行请求的对象区分开来。

##### **调用对象** 

`NSInvocation`类的实例用于封装Objective-C消息。一个调用对象中含有一个目标对象、一个方法选择器、以及方法参数。您可以动态地改变调用对象中消息的目标及其参数，一旦消息被执行，您就可以从该对象得到返回值。通过一个调用对象可以多次调用目标或参数不同的消息。

创建`NSInvocation`对象需要使用`NSMethodSignature`对象，该对象负责封装与方法参数和返回值有关系的信息。`NSMethodSignature`对象的创建又需要用到一个方法选择器。`NSInvocation`的实现还用到Objective-C运行环境的一些函数。

NSInvocation对象是分布式、撤消管理、消息传递、和定时器对象编程接口的一部分。在需要去除消息发送对象和接收对象之间的耦合关系的类似场合下，您也可以使用。

##### **目标-动作**

​	目标-动作机制使控件对象—也就是象按键或文本输入框这样的对象—可以将消息发送给另一个可以对消息进行解释并将它处理为具体应用程序指令的对象。接收对象，或者说是目标，通常是一个定制的控制器对象。消息—也被称为动作消息—由一个选择器来确定，选择器是一个方法的唯一运行时标识。典型情况下，控件拥有的单元对象会对目标和动作进行封装，以便在用户点击或激活控件时发送消息（菜单项也封装了目标和动作，以便在用户选择时发送动作消息）。目标-动作机制之所以能够基于选择器（而不是方法签名），是因为Cocoa规定动作方法的签名和选择器名称总是一样的。

##### **解释器模式** 

​	给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。



##### **迭代器模式** 

​	这种模式提供一种顺序访问聚合对象（也就是一个集合）中的元素，而又不必暴露潜在表示的方法。迭代器模式将访问和遍历集合元素的责任从集合对象转移到迭代器对象。迭代器定义一个访问集合元素的接口，并对当前元素进行跟踪。不同的迭代器可以执行不同的遍历策略



##### **中介者模式** 

​	用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

##### **归档** 

​	归档将一个程序中的对象以及对象的属性（包括属性和关系）存储到档案上，使之可以保存到文件系统中，或者在不同的处理器和网络间传递。档案将程序的对象图保存为独立于架构的字节流，对象的标识和对象之间的关系都会被保留。由于对象的类型和它的数据一起被存储，从归档的字节流解码出来的对象会被正常实例化，实例化所用的类与原来编码的类相同。

##### **属性列表的序列化**

​	属性列表是一个简单的、具有一定结构的对象图序列，它仅使用下面这些类的对象：`NSDictionary`、`NSArray`、`NSString`、`NSData`、`NSDate`、和`NSNumber`。这些对象通常也被称为属性列表对象。Cocoa中有几个框架类提供了序列化属性列表对象，以及定义录写对象内容及其层次关系的特殊数据流格式的方法。`NSPropertyListSerialization`类就提供了将属性列表对象序列化为XML或其它优化的二进制格式的类方法。

##### **状态模式** 

​	允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

##### **策略模式** 

​	定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

##### **模板方法模式** 

​	这种模式为某个操作中的算法定义框架，并将算法中的某些步骤推迟到子类实现。模板方法模式使子类可以重定义一个算法中的特定步骤，而不需要改变算法的结构。

##### **访问者模式**

​	表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。