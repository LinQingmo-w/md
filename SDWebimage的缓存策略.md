## 文件结构

​	文件目录

<img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9zjzv3ivbj30hk1341kx.jpg" alt="image-20191217112210134" style="zoom:50%;" />

## 缓存机制

[链接](https://blog.csdn.net/Philm_iOS/article/details/81200624)

在`SDImageCache`，图片采用了二级缓存策略。图片缓存时，在内存有缓存，在磁盘中也有缓存。其中，内存缓存是通过`NSCache`实现的。

#### 1. 缓存步骤：

SDImageCache

1. 将图片缓存在内存中
2. 判断图片的格式是png或是jpeg，将图片转化为`NSData`数据
3. 如果是在mac_os系统中，直接将图片转化为`NSBitmapImageRep`数据
4. 获取图片的存储路径，其中图片的文件名是通过传入的key经过md5加密后获得的。
5. 将图片存储磁盘中



#### 2. 获取图片步骤

1. 先在内存缓存中寻找
2. 如果内存中找不到图片，则在默认的磁盘根目录中寻找，如果还是找不到，再从自定义的只读目录路径中寻找
3. 获取图片数据后，将图片数据从`NSData`转化为`UIImage`,转化是要根据图片的类型进行转化。
4. 默认对图片进行解压缩，生成位图图片。
5. 将位图图片返回。

#### 3. 图片解压缩步骤

1. 判断图片是否是动态图片，如果是，则不能解压缩
2. 判断图片是否是透明的，如果是，则不能解压缩
3. 判断图片的颜色空间模型是不是RGB，如果不是，不能解压缩
4. 根据图片的大小创建一个上下文
5. 将图片绘制在上下文中。
6. 从上下文中读取一个不透明的位图图像，该图像就是解压缩后的图像
7. 将位图图像返回



#### 4. 对图片进行缩放步骤

1. 如果是普通图像，则直接进行缩放
2. 如果是动态图像，则要对图像中的每一张图像都进行缩放



#### 5. 磁盘缓存清理步骤 

1. 获取磁盘中图片的最后修改日期。(为了减少磁盘和内存数据交换，读取是并不将整个文件读入内存，仅仅将文件的一些属性读入内存中，包括最后修改日期，该文件是否为文件夹，文件的大小和对应文件的文件路径)

2. 根据最后修改日期将图片进行分类，将那些已经存放超过最长存放时间的文件存储在删除数组，其他的文件信息存储在另一个字典中。并计算除去要删除的文件之外的所有文件大小

3. 根据删除数组中的文件路径，将对应的文件删除。

4. 判断剩下的文件大小是否超过用户现在的磁盘最大容量。

5. 如果超过，则将剩余的文件进行安修改时间进行升序排列，然后删除修改时间最早的文件，直到甚剩余文件大小小于最大磁盘容量的一半。

	

#### 6. 图片缓存清理时机 

1. 当系统发出内存不足通知时，会将内存中的所有图片缓存都删除掉。
2. 当程序进入后台时，会对磁盘的文件数据进行清理。
3. 当收到程序关闭通知时，会对磁盘中的文件数据进行清理。

#### 7. 如何判断imageData的图片类型。

根据imageData的第一个字节，可以判断其图片类型。

| 第一个字节 | 图片类型                                                     |
| ---------- | ------------------------------------------------------------ |
| 0xFF       | jpeg                                                         |
| 0x89       | png                                                          |
| 0x47       | gif                                                          |
| 0x4D\0x49  | tiff                                                         |
| 0x52       | 将imageData的前12个字节转化为字符串，如果是RIFF前缀和WEBP后缀，则图片类型是webp“ |



## 相关内容

#### 数据清理：

1. 删除过期日期之前的文件。最大缓存：一周

2. 存储用于基于大小的清理过程的文件属性。

	//如果我们剩余的磁盘缓存超过配置的最大大小，请执行第二次
	         //基于大小的清理过程。 我们首先删除最早的文件。
	         如果（self.maxCacheSize> 0 && currentCacheSize> self.maxCacheSize）{
	             //为此清理过程指定最大缓存大小的一半。

	  //按剩余的最后修改时间（最早的时间）对其余缓存文件进行排序。

	//循环   按顺序删除文件，直到达到所需的缓存大小以下。

3. 有设置跳过的部分

4. 收到内存警告-清理内存。系统关闭-清理磁盘。应用到后台-通过标记您停止或直接结束任务的位置来清理所有未完成的任务业务。启动长时间运行的任务并立即返回。

#### 数据下载

1. 当下载大量图像时，会自动释放位图上下文和所有变量，以在出现内存警告时帮助系统释放内存。 在iOS7上，不要忘记调用[[SDImageCache sharedImageCache] clearMemory]；

2. 下载超时默认15s
3. 异步下载，相关url的内容有属性可以设置
4. 包含暂停和取消下载方法
5. 数据队列：包含数据队列，后台队列，数据个数，预期大小。



#### Manage





---

## 视频讲解

SDWebImage 5.0 后 面向协议编程 

异步下载，图片解压缩





 ![SDWebImageClassDiagram](https://tva1.sinaimg.cn/large/006tNbRwly1ga6pv71b19j30zo0u07eo.jpg)

- 上层api：分类，扩展

	分类：原理，区别，特性

- 核心：SDWebImageManage  收集任务， 分发任务

	

	sdwebImage

	获取manager ，使用它发起任务

	添加复用标示（类名），判断控件上有且只有一个任务。--字典(NSMapTable)存取任务。NSMapTable:可设置存储规则，key值存储不用按规定copy，（dic用copy），付值两个会有两个健值对，因为copyWithZone。vaule用weak，就是一份值。对象实现了copy，则作为key会复制出来一个，hash值不同。实现了isEqual,hash，则能判断想相同--需要有内容。

	

	发起请求，由manage发起，根据url发起请求，或从缓存中取。添加缓存。

	需要设置cancel。

	用strong会调用objc_strong();

	能从缓存取，就需要能取消

	设计api要考虑调用需求。有单利有init方法，可以选择调用。

	网络加载任务和缓存查询任务。

	manage区分cacheOperation和loaderOperation,分别是查询缓存和网络请求。

	-- 面向接口编程。通过协议进行相互间的注册调用。更易做拆分。

	

	- cache：优先内存缓存；没有了查找磁盘缓存，查到了把它加载到内存中提高下一次命中率。

	NSCache: 线程安全，key强引用，自动进行缓存清理. 类似于字典。

	cache缓存，用了一个子类：SDMemorryCache，继承NSCache，重写了setObject:forKey: 给了一个标示。 然后在进行存储。

	![image-20191223185446572](https://tva1.sinaimg.cn/large/006tNbRwly1ga6usmxtxxj311i0emn7j.jpg)

	假设：当前obj引用计数为1，强引用后引用计数为2.unlock后变为1，还在内存中。单unlock后认为不再缓存里面了。就要从磁盘在家再一次，所以不高效。

	声明nsmapTable.使用weak，不影响当前对象的生命周期。对象就会存在弱引用表中。就可以查找。用空间换取时间，以提高命中率

	

	## 优化：

	1. barItem

	2. 同名url怎么更新

	

	





